

Serializing Values
------------------


First define a record type::

    >>> from application import schema
    >>> from osaf import sharing, pim
    >>> from osaf.sharing import ( eimml, recordset_conduit, State, getFilter,
    ...     Inherit, RecordSet as rs, NoChange as nc )
    >>> from PyICU import ICUtzinfo
    >>> import datetime, decimal
    >>> from repository.persistence.RepositoryView import NullRepositoryView
    >>> rv = NullRepositoryView()
    >>> class TestRecord(sharing.Record):
    ...     URI = 'cid:TestRecord@osaf.us'
    ...     textField = sharing.field(sharing.TextType(size=100))
    ...     decimalField = sharing.field(sharing.DecimalType(digits=11,
    ...                                  decimal_places=2))
    ...     dateField = sharing.field(sharing.DateType)


Translate text values::

    >>> value = eimml.deserializeValue(TestRecord.textField.typeinfo, 'xyzzy')
    >>> value
    'xyzzy'
    >>> eimml.serializeValue(TestRecord.textField.typeinfo, value)
    ('xyzzy', 'text')


Translate decimal values::

    >>> value = eimml.deserializeValue(TestRecord.decimalField.typeinfo, '123.45')
    >>> value
    Decimal("123.45")
    >>> eimml.serializeValue(TestRecord.decimalField.typeinfo, value)
    ('123.45', 'decimal')


Translate datetime values::

    >>> value = eimml.deserializeValue(TestRecord.dateField.typeinfo,
    ... '2007-01-30T15:45:30.098593-08:00')
    >>> value
    datetime.datetime(2007, 1, 30, 15, 45, 30, 98593, tzinfo=<ICUtzinfo: Etc/GMT+8>)
    >>> eimml.serializeValue(TestRecord.dateField.typeinfo, value)
    ('2007-01-30T15:45:30.098593-08:00', 'datetime')

TODO: int, lob, bytes




Serialize and deserialize entire record sets using EIMMLSerializer::


    >>> sample = '''<?xml version='1.0' encoding='UTF-8'?>
    ...
    ... <eim:collection name="foo" uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" xmlns:eim="http://osafoundation.org/eim/0">
    ...   <eim:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214">
    ...     <item:record xmlns:item="http://osafoundation.org/eim/item/0">
    ...       <item:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></item:uuid>
    ...       <item:title eim:type="text"><![CDATA[Welcome to Cosmo]]></item:title>
    ...       <item:triage eim:type="text">100 123456789.12 1</item:triage>
    ...       <item:createdOn eim:type="decimal"><![CDATA[1164803131]]></item:createdOn>
    ...       <item:hasBeenSent eim:type="integer">0</item:hasBeenSent>
    ...       <item:needsReply eim:type="integer">0</item:needsReply>
    ...     </item:record>
    ...     <modby:record xmlns:modby="http://osafoundation.org/eim/modifiedBy/0">
    ...       <modby:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></modby:uuid>
    ...       <modby:userid eim:type="text"><![CDATA[foo@example.com]]></modby:userid>
    ...       <modby:timestamp eim:type="decimal"><![CDATA[1164803132]]></modby:timestamp>
    ...       <modby:action eim:type="integer">500</modby:action>
    ...     </modby:record>
    ...     <note:record xmlns:note="http://osafoundation.org/eim/note/0">
    ...       <note:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></note:uuid>
    ...       <note:body eim:type="clob">This is the body\nsecond line</note:body>
    ...       <note:icalUid eim:type="text"><![CDATA[1e2d48c0-d66b-494c-bb33-c3d75a1ba66b]]></note:icalUid>
    ...       <note:icalParameters eim:type="text" />
    ...       <note:icalProperties eim:type="text" />
    ...     </note:record>
    ...     <event:record xmlns:event="http://osafoundation.org/eim/event/0">
    ...       <event:uuid eim:type="text" eim:key="true"><![CDATA[8501de14-1dc9-40d4-a7d4-f289feff8214]]></event:uuid>
    ...       <event:dtstart eim:type="text"><![CDATA[20061130T140000]]></event:dtstart>
    ...       <event:duration eim:type="text"><![CDATA[PT1H]]></event:duration>
    ...       <event:location eim:type="text"><![CDATA[San Jose]]></event:location>
    ...       <event:rrule eim:type="text"><![CDATA[FREQ=WEEKLY]]></event:rrule>
    ...       <event:exrule eim:type="text" />
    ...       <event:rdate eim:type="text" />
    ...       <event:exdate eim:type="text" />
    ...       <event:status eim:type="text"><![CDATA[CONFIRMED]]></event:status>
    ...     </event:record>
    ...   </eim:recordset>
    ... </eim:collection>'''

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(sample)

    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131"), 0, 0), sharing.model.ModifiedByRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132"), 500), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body\nsecond line', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'PT1H', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')])}

    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo', 'uuid': '9501de14-1dc9-40d4-a7d4-f289feff8214'}

    >>> text = eimml.EIMMLSerializer.serialize(recordSets, name="foo")

    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True

    >>> extra
    {'name': 'foo'}


Fields with empty strings are serialized with an empty="true" attribute on
their element::

    >>> records = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', '', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None)])}
    >>> text = eimml.EIMMLSerializer.serialize(records)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record xmlns:ns1="http://osafoundation.org/eim/note/0"><ns1:uuid ns0:key="true" ns0:type="text">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid><ns1:body empty="true" ns0:type="clob" /><ns1:icalUid ns0:type="text">1e2d48c0-d66b-494c-bb33-c3d75a1ba66b</ns1:icalUid><ns1:icalProperties ns0:type="text" /><ns1:icalParameters ns0:type="text" /></ns1:record></ns0:recordset></ns0:collection>'
    >>> newRecords, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> records == newRecords
    True

Any records in a recordset's exclusions are serialized as deletions::

    >>> recordDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs(set([]), set([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131"), 0, 0)]))}
    >>> text = eimml.EIMMLSerializer.serialize(recordDeletion)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214"><ns1:record ns0:deleted="true" xmlns:ns1="http://osafoundation.org/eim/item/0"><ns1:uuid ns0:key="true" ns0:type="text">8501de14-1dc9-40d4-a7d4-f289feff8214</ns1:uuid></ns1:record></ns0:recordset></ns0:collection>'

To indicate that item has been deleted, pass None instead of a recordset::

    >>> itemDeletion = { '8501de14-1dc9-40d4-a7d4-f289feff8214' : None }
    >>> text = eimml.EIMMLSerializer.serialize(itemDeletion)
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="8501de14-1dc9-40d4-a7d4-f289feff8214" ns0:deleted="true" /></ns0:collection>'



There is a special value, Inherit, which gets serialized as missing="true"::

    >>> missing = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', Inherit, u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None)])}
    >>> text = eimml.EIMMLSerializer.serialize(missing)
    >>> imported, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> imported
    {'8501de14-1dc9-40d4-a7d4-f289feff8214': RecordSet(set([NoteRecord(u'8501de14-1dc9-40d4-a7d4-f289feff8214', Inherit, u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None)]), set([]))}






Records can be sorted by their dependencies. To make a record type dependent
on another, make one of the first record type's fields' type be the field of
another.  For instance, NoteRecord's uuid field = eim.key(ItemRecord.uuid)::

    >>> r1 = sharing.model.ItemRecord('1', None, nc, nc, nc, nc)
    >>> r2 = sharing.model.NoteRecord('1', None, nc, nc, nc)
    >>> r3 = sharing.model.EventRecord('1', None, nc, nc, nc, nc, nc, nc, nc)
    >>> r4 = sharing.model.DisplayAlarmRecord('1', nc, None, nc, nc)
    >>> list(sharing.sort_records( [r3, r1, r4, r2] ))
    [ItemRecord(u'1', None, NoChange, NoChange, NoChange, NoChange), NoteRecord(u'1', None, NoChange, NoChange, NoChange), EventRecord(u'1', None, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange), DisplayAlarmRecord(u'1', NoChange, None, NoChange, NoChange)]

Sorting works even if not all record types are represented::

    >>> list(sharing.sort_records( [r3, r1, r4] ))
    [ItemRecord(u'1', None, NoChange, NoChange, NoChange, NoChange), EventRecord(u'1', None, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange), DisplayAlarmRecord(u'1', NoChange, None, NoChange, NoChange)]

    >>> list(sharing.sort_records( [r4, r3] ))
    [EventRecord(u'1', None, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange, NoChange), DisplayAlarmRecord(u'1', NoChange, None, NoChange, NoChange)]

    >>> sortedSets = {'1': rs([r4, r1, r3])}
    >>> eimml.EIMMLSerializer.serialize(sortedSets)
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection xmlns:ns0="http://osafoundation.org/eim/0"><ns0:recordset uuid="1"><ns1:record xmlns:ns1="http://osafoundation.org/eim/item/0"><ns1:uuid ns0:key="true" ns0:type="text">1</ns1:uuid><ns1:title ns0:type="text" /></ns1:record><ns1:record xmlns:ns1="http://osafoundation.org/eim/event/0"><ns1:uuid ns0:key="true" ns0:type="text">1</ns1:uuid><ns1:dtstart ns0:type="text" /></ns1:record><ns1:record xmlns:ns1="http://osafoundation.org/eim/displayAlarm/0"><ns1:uuid ns0:key="true" ns0:type="text">1</ns1:uuid><ns1:trigger ns0:type="text" /></ns1:record></ns0:recordset></ns0:collection>'






Inmemory Mock Cosmo
-------------------

You can "send" a recordset::

    >>> conduit = recordset_conduit.InMemoryDiffRecordSetConduit(itsView=rv,
    ...     shareName="test1", serializer=eimml.EIMMLSerializer)
    >>> conduit.put(sample)
    >>> conduit.syncToken
    '1'

If you don't use the previous token, you'll get a failure::

    >>> conduit.syncToken = '42'
    >>> conduit.put(sample)
    Traceback (most recent call last):
    ...
    TokenMismatch: 42 != 1

The token changes whenever you modify the collection::

    >>> conduit.syncToken = '1'
    >>> conduit.put(sample)
    >>> conduit.syncToken
    '2'

Send a new item::

    >>> text = '''<?xml version='1.0' encoding='UTF-8'?>
    ...
    ... <eim:collection name="foo" uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" xmlns:eim="http://osafoundation.org/eim/0">
    ...   <eim:recordset uuid="9501de14-1dc9-40d4-a7d4-f289feff8214">
    ...     <item:record xmlns:item="http://osafoundation.org/eim/item/0">
    ...       <item:uuid eim:type="text" eim:key="true"><![CDATA[9501de14-1dc9-40d4-a7d4-f289feff8214]]></item:uuid>
    ...       <item:title eim:type="text"><![CDATA[Welcome to Cosmo]]></item:title>
    ...       <item:triage eim:type="text">100 123456789.12 1</item:triage>
    ...       <item:createdOn eim:type="decimal"><![CDATA[1164803132]]></item:createdOn>
    ...       <item:hasBeenSent eim:type="integer">0</item:hasBeenSent>
    ...       <item:needsReply eim:type="integer">0</item:needsReply>
    ...     </item:record>
    ...     <modby:record xmlns:modby="http://osafoundation.org/eim/modifiedBy/0">
    ...       <modby:uuid eim:type="text" eim:key="true"><![CDATA[9501de14-1dc9-40d4-a7d4-f289feff8214]]></modby:uuid>
    ...       <modby:userid eim:type="text"><![CDATA[foo@example.com]]></modby:userid>
    ...       <modby:timestamp eim:type="decimal"><![CDATA[1164803132]]></modby:timestamp>
    ...       <modby:action eim:type="integer">500</modby:action>
    ...     </modby:record>
    ...     <note:record xmlns:note="http://osafoundation.org/eim/note/0">
    ...       <note:uuid eim:type="text" eim:key="true"><![CDATA[9501de14-1dc9-40d4-a7d4-f289feff8214]]></note:uuid>
    ...       <note:body eim:type="clob">This is the body\nsecond line</note:body>
    ...       <note:icalUid eim:type="text"><![CDATA[1e2d48c0-d66b-494c-bb33-c3d75a1ba66b]]></note:icalUid>
    ...       <note:icalParameters eim:type="text" />
    ...       <note:icalProperties eim:type="text" />
    ...     </note:record>
    ...     <event:record xmlns:event="http://osafoundation.org/eim/event/0">
    ...       <event:uuid eim:type="text" eim:key="true"><![CDATA[9501de14-1dc9-40d4-a7d4-f289feff8214]]></event:uuid>
    ...       <event:dtstart eim:type="text"><![CDATA[20061130T140000]]></event:dtstart>
    ...       <event:duration eim:type="text"><![CDATA[PT1H]]></event:duration>
    ...       <event:rrule eim:type="text"><![CDATA[FREQ=WEEKLY]]></event:rrule>
    ...       <event:location eim:type="text" />
    ...       <event:exrule eim:type="text" />
    ...       <event:rdate eim:type="text" />
    ...       <event:exdate eim:type="text" />
    ...       <event:status eim:type="text"><![CDATA[CONFIRMED]]></event:status>
    ...     </event:record>
    ...   </eim:recordset>
    ... </eim:collection>'''

    >>> conduit.put(text)
    >>> conduit.syncToken
    '3'

Doing a "get" with the most recent token returns no changes::

    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> text
    '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ns0:collection name="foo" uuid="9501de14-1dc9-40d4-a7d4-f289feff8214" xmlns:ns0="http://osafoundation.org/eim/0" />'

You can ask for recordsets that have been updated since a previous token was
created::

    >>> conduit.syncToken = '1'
    >>> text = conduit.get()
    >>> conduit.syncToken
    '3'
    >>> expectedRecordSets = { '8501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803131"), 0, 0), sharing.model.ModifiedByRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132"), 500), sharing.model.NoteRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body\nsecond line', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None), sharing.model.EventRecord('8501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'PT1H', u'San Jose', u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]), '9501de14-1dc9-40d4-a7d4-f289feff8214': rs([sharing.model.ItemRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'Welcome to Cosmo', u'100 123456789.12 1', decimal.Decimal("1164803132"), 0, 0), sharing.model.ModifiedByRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'foo@example.com', decimal.Decimal("1164803132"), 500), sharing.model.NoteRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', 'This is the body\nsecond line', u'1e2d48c0-d66b-494c-bb33-c3d75a1ba66b', None, None), sharing.model.EventRecord('9501de14-1dc9-40d4-a7d4-f289feff8214', u'20061130T140000', u'PT1H', None, u'FREQ=WEEKLY', None, None, None, u'CONFIRMED')]) }
    >>> recordSets, extra = eimml.EIMMLSerializer.deserialize(text)
    >>> recordSets == expectedRecordSets
    True





Merging RecordSets
------------------

The RecordSetConduit class has a merge method which will compare inbound
and outbound changes, merge the non-overlapping changes, and return the
set of records to send outbound, the set of records to apply locally, and
the inbound changes that are pending due to conflict::

    >>> empty = rs()

    >>> barFilter = sharing.Filter('cid:bar-filter@osaf.us', u"Bars")
    >>> bazFilter = sharing.Filter('cid:baz-filter@osaf.us', u"Bazzes")

    >>> import osaf.sharing
    >>> __name__ = "osaf.sharing"
    >>> class Demo(sharing.Record):
    ...     URI = 'cid:eim.test.demo-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo = Demo

    >>> state = State(itsView=rv)

Verify the state is empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Test a no-op (no inbound nor outbound changes)::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state is still empty
    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Merge a local addition with no inbound changes::

    >>> state.merge(rs([Demo(1, 1, 1)]), empty)
    (RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

Verify the state has been updated::

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])))


Merge in an inbound change (no outbound changes)::

    >>> state.merge(rs([Demo(1, 1, 1)]), rs(set([Demo(1, 1, 2)])))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 2)]), set([])), RecordSet(set([]), set([])))


Merge non-overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 3, 2)]), rs([Demo(1, 1, 3)]))
    (RecordSet(set([Demo(1, 3, NoChange)]), set([])), RecordSet(set([Demo(1, NoChange, 3)]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 3)]), set([])), RecordSet(set([]), set([])))


Merge overlapping and non-overlapping inbound and outbound changes, resulting
in pending inbound changes::

    >>> state.merge(rs([Demo(1, 4, 4)]), rs([Demo(1, 5, nc)]))
    (RecordSet(set([Demo(1, NoChange, 4)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 4)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


With pending changes, non-conflicting local modifications can still go out::

    >>> state.merge(rs([Demo(1, 4, 5)]))
    (RecordSet(set([Demo(1, NoChange, 5)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 3, 5)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))


See that a pending change can disappear due to a later inbound change:

    >>> state.merge(rs([Demo(1, 4, 5)]), rs([Demo(1, 4, 5)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([]), set([])))


Merge only overlapping inbound and outbound changes::

    >>> state.merge(rs([Demo(1, 4, 6)]), rs([Demo(1, 4, 7)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Add in a filter, make a local change and no inbound changes::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 6, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 7)]), set([])))


Even though we locally modified the 'bar' field, it is not sent because of
the filter.  Even though we locally modified the 'baz' field, since there is
an outstanding pending change it is also not sent.

See that a pending change can disappear due to a later outbound change:

    >>> state.merge(rs([Demo(1, 6, 7)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


There can be multiple filters in effect; note how we locally change both fields
yet send nothing, and the agreed upon state doesn't change::

    >>> filter = getFilter(['cid:bar-filter@osaf.us', 'cid:baz-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 7)]), set([])), RecordSet(set([]), set([])))


Verify that inbound changes to filtered fields are not applied locally, yet
unfiltered inbound changes are applied::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 7, 8)]), rs([Demo(1, 5, 8)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 8)]), set([])), RecordSet(set([]), set([])))


Verify that inbound and outbound changes to a filtered field is not considered
a conflict::

    >>> state.merge(rs([Demo(1, 8, 9)]), rs([Demo(1, 9, 9)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 9)]), set([])), RecordSet(set([]), set([])))


Verify that conflicts can still be detected when at least one conflicting
field is not filtered::

    >>> state.merge(rs([Demo(1, 9, 10)]), rs([Demo(1, 10, 11)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 4, 9)]), set([])), RecordSet(set([Demo(1, NoChange, 11)]), set([])))




Start over, to test that when a filter is removed, the local change that was
hiding behind the filter is now sent::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(rs([Demo(1, 2, 2)]), rs([Demo(1, 3, nc)]), filter=filter)
    (RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 1, 2)]), set([])), RecordSet(set([]), set([])))

Note how the agreed state does not contain either the local change or the
inbound change above.  Now remove the filter and merge::

    >>> state.merge(rs([Demo(1, 2, 2)]))
    (RecordSet(set([Demo(1, 2, NoChange)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))

See how the local change finally got sent out above.



Start over with a filter in place from the start.  Note now the filtered
portion of the inbound changes are NoChange in the state's agreed rs::

    >>> state.set(empty, empty)
    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.merge(empty, rs([Demo(1, 2, 2)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])))

Now apply the same inbound change without the filter::

    >>> state.merge(rs([Demo(1,nc,2)]), rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, NoChange)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))

Now in reality, the item involved will have some sort of default value for the
field that was filtered, so lifting the filter in this way will create a
conflict if the local value is different than the inbound::

    >>> state.set(rs(set([Demo(1,nc,2)])), empty)
    >>> state.merge(rs([Demo(1,1,2)]), rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, NoChange)]), set([])))

...However, if the local change happens to be the same, then no conflict::

    >>> state.set(rs(set([Demo(1,nc,2)])), empty)
    >>> state.merge(rs([Demo(1,2,2)]), rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))




Start over, to test that local deletions get sent::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)

    >>> state.merge(empty)
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))



Start over, to test that remote deletions get applied::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 1, 1)]), rs([], [Demo(1, Inherit, Inherit)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])))



Start over, to test that local changes and remote deletions get detected::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, 2, 2)]), rs([], [Demo(1, Inherit, Inherit)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([Demo(1, 1, 1)])))


Start over, to test that local deletions and remote changes get detected::


    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(empty, rs([Demo(1, 2, 2)]))
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))

    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])))







Start over, adding two records (one of a new record type)::

    >>> class Demo2(sharing.Record):
    ...     URI = 'cid:eim.test.demo2-record@osaf.us'
    ...     foo = sharing.key(int)
    ...     bar = sharing.field(int, [barFilter])
    ...     baz = sharing.field(int, [bazFilter])
    >>> osaf.sharing.Demo2 = Demo2

    >>> state.set(rs(set([Demo(1,1,1), Demo2(1,2,2)])), empty)

...now remove the Demo(1,1,1), and the result of the merge will be that we
will send a deletion for that record::

    >>> state.merge(rs([Demo2(1, 2, 2)]))
    (RecordSet(set([]), set([Demo(1, 1, 1)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([Demo2(1, 2, 2)]), set([])), RecordSet(set([]), set([])))


If a record is removed inbound and outbound, that is not a conflict.  Note
that a double-deletion results in an unnecessary record deletion in toApply,
but record adding and deleting need to be idempotent anyway, so it's ok::

    >>> state.merge(empty, empty)
    (RecordSet(set([]), set([Demo2(1, 2, 2)])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

    >>> state
    State(RecordSet(set([]), set([])), RecordSet(set([]), set([])))




Start over, with a filter this time from the start::

    >>> filter = getFilter(['cid:bar-filter@osaf.us'])
    >>> state.set(empty, empty)

Merge a local addition with no inbound changes; note that the outbound
record has a NoChange value on the filtered field::

    >>> state.merge(rs([Demo(1, 1, 1)]), filter=filter)
    (RecordSet(set([Demo(1, NoChange, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))





Start over, using a filter that completely filters out an entire record::

    >>> demo3Filter = sharing.Filter('cid:demo3-filter@osaf.us', u"Demo3")
    >>> class Demo3(sharing.Record):
    ...     URI = 'cid:eim.test.demo3-record@osaf.us'
    ...     a = sharing.key(int)
    ...     b = sharing.field(int, [demo3Filter])
    ...     c = sharing.field(int, [demo3Filter])
    >>> osaf.sharing.Demo3 = Demo3

Without a filter, this merge results in a record to send::

    >>> state.set(empty, empty)
    >>> state.merge(rs([Demo3(1, 1, 1)]))
    (RecordSet(set([Demo3(1, 1, 1)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))

With the filter in place, this merge results in nothing being sent::

    >>> filter = getFilter(['cid:demo3-filter@osaf.us'])
    >>> state.set(empty, empty)
    >>> state.merge(rs([Demo3(1, 1, 1)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))


With the filter in place, this merge results in nothing being applied::

    >>> state.set(rs(set([Demo3(1, 1, 1)])), empty)
    >>> state.merge(rs([Demo3(1, 1, 1)]), rs([Demo3(1, 2, 2)]), filter=filter)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))





Make sure Inherit values can be merged::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)
    >>> state.merge(rs([Demo(1, Inherit, 2)]))
    (RecordSet(set([Demo(1, Inherit, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, Inherit, 2)]), set([])), RecordSet(set([]), set([])))

    >>> state.merge(rs([Demo(1, Inherit, 2)]), rs([Demo(1, 2, Inherit)]))
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, Inherit)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, Inherit)]), set([])), RecordSet(set([]), set([])))

    >>> state.merge(rs([Demo(1, Inherit, 2)]), rs([Demo(1, 3, nc)]))
    (RecordSet(set([Demo(1, NoChange, 2)]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 3, NoChange)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([Demo(1, 3, NoChange)]), set([])))



Read-only Merging
-----------------

If we have subscribed to a read-only share, we can allow the user to make
changes, but we don't send the changes out.  In order for conflicts to work
well, the 'agreed' state should only get records that are inbound, and never
local changes.


    >>> state.set(rs(set([Demo(1,1,1)])), empty)

A local change does not appear in toSend nor in the state's "agreed"::

    >>> state.merge(rs([Demo(1, 2, 1)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])))

An external change *does* appear in toApply and the state's "agreed"::

    >>> state.merge(rs([Demo(1, 1, 1)]), rs([Demo(1, 2, 2)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 2)]), set([])), RecordSet(set([]), set([])))

A local change coupled with a non-overlapping external change results in the
external change getting applied to "agreed"::

    >>> state.merge(rs([Demo(1, 3, 2)]), rs([Demo(1, 2, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 3)]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 2, 3)]), set([])), RecordSet(set([]), set([])))

A local change coupled with an overlapping external change results in the
external change getting applied to "agreed", and the conflict appears in
"pending"::

    >>> state.merge(rs([Demo(1, 4, 3)]), rs([Demo(1, 5, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 5, 3)]), set([])), RecordSet(set([Demo(1, 5, NoChange)]), set([])))

Discarding the conflicts, the conflicts should not reappear.  First verifying
this with no changes::

    >>> state.set(rs(set([Demo(1,5,3)])), empty)
    >>> state.merge(rs([Demo(1, 5, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 5, 3)]), set([])), RecordSet(set([]), set([])))

Now verifying that a local change will not result in a conflict (nor state
change)::

    >>> state.merge(rs([Demo(1, 6, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 5, 3)]), set([])), RecordSet(set([]), set([])))

A new identical external change coupled with our previously-made local change
*should not* result in a conflict, but it should update the state::

    >>> state.merge(rs([Demo(1, 6, 3)]), rs([Demo(1, 6, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 6, 3)]), set([])), RecordSet(set([]), set([])))

A local change coupled with an overlapping external change should generate
a conflict and the state should reflect the external change::

    >>> state.merge(rs([Demo(1, 7, 3)]), rs([Demo(1, 8, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 8, NoChange)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 8, 3)]), set([])), RecordSet(set([Demo(1, 8, NoChange)]), set([])))

Making local and external changes to another field should add a new conflict
while keeping the old one too:

    >>> state.merge(rs([Demo(1, 7, 4)]), rs([Demo(1, 8, 5)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, 8, 5)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 8, 5)]), set([])), RecordSet(set([Demo(1, 8, 5)]), set([])))

Applying one part of pending changes should make that conflict go away::

    >>> state.merge(rs([Demo(1, 8, 3)]), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([Demo(1, NoChange, 5)]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 8, 5)]), set([])), RecordSet(set([Demo(1, NoChange, 5)]), set([])))


Ensure record removal works too, by adding a new record locally, then also
remotely, then remove it remotely::

    >>> state.set(rs(set([Demo(1,1,1)])), empty)

    >>> state.merge(rs(set([Demo(1,1,1), Demo2(1,1,1)])), empty, send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state
    State(RecordSet(set([Demo(1, 1, 1)]), set([])), RecordSet(set([]), set([])))

    >>> state.merge(rs(set([Demo(1,1,1), Demo2(1,1,1)])), rs(set([Demo(1,1,1), Demo2(1,1,1)])), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([])), RecordSet(set([]), set([])))
    >>> state.agreed == rs(set([Demo(1, 1, 1), Demo2(1, 1, 1)]))
    True
    >>> state.pending == empty
    True

    >>> state.merge(rs(set([Demo(1,1,1), Demo2(1,1,1)])), rs(set([]), set([Demo2(1,1,1)])), send=False)
    (RecordSet(set([]), set([])), RecordSet(set([]), set([Demo2(1, 1, 1)])), RecordSet(set([]), set([])))



Itemcentric Sharing
-------------------

Items can be shared with a peer without using a persistent Share/Conduit.
The sharing package provides methods for translating items to EIMML and
back.

    >>> rv0 = NullRepositoryView()
    >>> rv1 = NullRepositoryView()
    >>> item0 = pim.Note(itsView=rv0, displayName="test displayName",
    ...     body="test body")
    >>> item0.setTriageStatus(pim.TriageEnum.later)
    >>> uuid = item0.itsUUID.str16()
    >>> not pim.has_stamp(item0, sharing.SharedItem)
    True

    >>> pje = schema.Item(itsView=rv0)
    >>> morgen = schema.Item(itsView=rv1)

An item is serialized to EIMML using the outbound method.  The first
argument is a list of items which identifies the peer(s) we're
sharing with; the sharing package doesn't care what this item is;
it could be a Contact item, or email address item, etc., as long
as it's a persistent Chandler item.

    >>> text = sharing.outbound([pje], item0)

Sharing an item this way automatically stamps the item as SharedItem.

    >>> pim.has_stamp(item0, sharing.SharedItem)
    True

You can check for conflicts using sharing.hasConflicts::

    >>> sharing.hasConflicts(item0)
    False

An item is imported via the inbound method.

    >>> item1 = sharing.inbound(morgen, text)
    >>> item1 is not None
    True
    >>> pim.has_stamp(item1, sharing.SharedItem)
    True

    >>> item1.displayName
    u'test displayName'

    >>> item1.body
    u'test body'

    >>> item1._triageStatus
    TriageEnum.later

Send changes back

    >>> item1.setTriageStatus(pim.TriageEnum.now)
    >>> text = sharing.outbound([morgen], item1)
    >>> item0 = sharing.inbound(pje, text)
    >>> item0._triageStatus
    TriageEnum.now

You can see if an item has conflicts by calling hasConflicts()::

    >>> sharing.hasConflicts(item0)
    False

    >>> shared1 = sharing.SharedItem(item1)
    >>> sharing.hasConflicts(item1)
    False

Cause a conflict::

    >>> item0.displayName = u'changed by morgen'
    >>> item1.displayName = u'changed by pje'
    >>> text = sharing.outbound([pje], item0)
    >>> item1 = sharing.inbound(morgen, text)

See if a conflict exists for this item::

    >>> sharing.hasConflicts(item1)
    True

Get the list of conflicts::

    >>> list(shared1.getConflicts())
    [title : changed by morgen]

A conflict has two attributes that the UI is going to care about, "field" and
"value".  At the moment, "field" is always the string "Something", and "value"
is simply a dumb string conversion of the conflicting recordset.  Soon we will
break out each conflicting field into its own Conflict object that can be
applied or discarded independently.


You can apply() a conflict, which goes ahead and applies those pending changes
to the item::

    >>> item1.displayName
    u'changed by pje'

    >>> for conflict in sharing.getConflicts(item1):
    ...     conflict.apply()

Verify the pending change was applied::

    >>> item1.displayName
    u'changed by morgen'

Once applied, conflicts go away::

    >>> sharing.hasConflicts(item1)
    False
    >>> list(shared1.getConflicts())
    []

Cause a conflict again::

    >>> item0.displayName = u'changed again by morgen'
    >>> item1.displayName = u'changed again by pje'
    >>> text = sharing.outbound([pje], item0)
    >>> item1 = sharing.inbound(morgen, text)
    >>> list(shared1.getConflicts())
    [title : changed again by morgen]

This time discard the conflict::

    >>> for conflict in shared1.getConflicts():
    ...     conflict.discard()

Again, the conflicts are gone::

    >>> sharing.hasConflicts(item1)
    False
    >>> list(shared1.getConflicts())
    []

For testing, you can generate fake conflicts::

    >>> shared1.generateConflicts()
    >>> sharing.hasConflicts(item1)
    True
